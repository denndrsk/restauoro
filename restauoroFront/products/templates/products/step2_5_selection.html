<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selection</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    {% load static %}
    <link rel="stylesheet" type="text/css" href="{% static 'css/styles_viewer.css' %}?v={{ now|date:'U' }}"> 

</head>
<body>
    <!-- Überschrift über dem Viewer -->
    <div id="header-message" style="font-weight: bold; font-size: 24px; text-align: center; margin-bottom: 20px;">
        Press and hold to select the damaged area.
    </div>
    <div id="header-message" style="font-weight: bold; font-size: 24px; text-align: center; margin-bottom: 20px;">
        Override the door thickness if neccesary.
    </div>

    <!-- Container für den STL-Viewer -->
    <div id="viewer-container"></div>

    <!-- Buttons und Eingabefeld unter dem Viewer -->
    <div id="buttons-container">
        <!-- Modell fehlerhaft Button -->
        <div class="buttons-container">
            <form method="POST" action="{% url 'step2_viewer' project_id=project_id %}">
                {% csrf_token %}
                <button type="submit" class="red-button">return</button>
            </form>
        </div>
        
        <div class="buttons-container">
            <button id="mode-toggle-button" class="yellow-button">switch to selection</button>          
        </div>
        
        
        <!-- Türdicke Eingabefeld -->
        <form method="POST" action="{% url 'step3_clean_up' project_id=project_id %}">
            {% csrf_token %}
            <div class="input-container">
                <label for="door_thickness" style="color: #FFD61C; font-weight: bold;">Door Thickness in cm</label>
                <input type="number" id="door_thickness" name="door_thickness" step="0.01" min="0" required value="{{ door_thickness }}">
            </div>
            <div class="input-container">
                <label for="scale_dimension" style="color: #FFD61C; font-weight: bold;">Horizontal Dimension in cm</label>
                <input type="number" id="scale_dimension" name="scale_dimension" step="0.01" min="0" required value="{{ scale_dimension }}">
            </div>
        </form>

        <!-- Modell bereinigen Button -->
        <div class="buttons-container">
            <form method="POST" action="{% url 'step3_clean_up' project_id=project_id %}">
                {% csrf_token %}
                <input type="hidden" id="hidden_door_thickness" name="door_thickness" value="">
                <input type="hidden" id="scale_factor" name="scale_factor" required value="">
                <input type="hidden" id="start_coordinates_x" name="start_coordinates_x" value="">
                <input type="hidden" id="start_coordinates_z" name="start_coordinates_z" value="">
                <input type="hidden" id="end_coordinates_x" name="end_coordinates_x" value="">
                <input type="hidden" id="end_coordinates_z" name="end_coordinates_z" value="">
                <input type="hidden" id="minY" name="minY" value="">
                <input type="hidden" id="maxY" name="maxY" value="">
                <input type="hidden" id="offset-y" name="offset-y" value="">
                <button type="submit" class="yellow-button">extrude & clean up</button>
            </form>
        </div>
    </div>
    <div id="coordinates-container">
        <p>Start Koordinaten: <span id="start-coordinates">X: 0, Z: 0</span></p>
        <p>End Koordinaten: <span id="end-coordinates">X: 0, Z: 0</span></p>
    </div>

    <!-- Three.js und STLLoader einbinden -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

    <script>
var modelDepth = 0; // Declare modelHeight globally
var modelFront = 0; // Declare modelHeight globally
var doorThickness = modelDepth; // Setze den Standardwert auf die Modell-Tiefe
var scene = new THREE.Scene();  // Definiere die Szene hier
// Orthogonalprojektion Kamera initialisieren
var camera = new THREE.OrthographicCamera(
    -50 * (width / height),  // linke Grenze angepasst an das Seitenverhältnis
    50 * (width / height),   // rechte Grenze angepasst an das Seitenverhältnis
    50,                      // obere Grenze
    -50,                     // untere Grenze
    0.1,                     // Nahbereich
    1000                     // Fernbereich
);
// Initialisiere den Renderer zuerst
var renderer = new THREE.WebGLRenderer({ antialias: true });
// Raycaster und Maus-Vector für die Auswahl
var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();

// Berechne die Breite und Höhe
var width = window.innerWidth * 0.8;  // 80% der Fensterbreite
var height = window.innerHeight * 0.8;  // 80% der Fensterhöhe

// Setze die Größe des Renderers
renderer.setSize(width, height);

// Füge den Renderer zum DOM hinzu (optional)
document.body.appendChild(renderer.domElement);
camera.left = -50 * (width / height);
camera.right = 50 * (width / height);
camera.updateProjectionMatrix();

document.getElementById('viewer-container').appendChild(renderer.domElement);
console.log("Renderer initialized");
// STLLoader und Modell-URL laden
var loader = new THREE.STLLoader();
var modelUrl = "{{ model_url }}";  // URL des bearbeiteten Modells
var mesh;
// STLLoader und Modell-URL laden
loader.load(modelUrl, function (geometry) {
    //console.log("STL Model loaded", geometry);  // Füge dies hinzu
    var material = new THREE.MeshStandardMaterial({ 
        color: 0x8A8A8A, 
        roughness: 0.5, 
        metalness: 0.1 
    });
    mesh = new THREE.Mesh(geometry, material)
    scene.add(mesh);
    mesh.position.set(0, 0, 0); 
    mesh.scale.set(1, 1, 1); 

    // Berechne die Bounding Box des Modells
    var boundingBox = new THREE.Box3().setFromObject(mesh);
    
    // Extrahiere die Höhe des Modells aus der Bounding Box (Y-Achse)
    modelFront = boundingBox.min.y;
    modelDepth = (boundingBox.max.y - boundingBox.min.y)* 100;
    console.log("Model depth: ", modelDepth); // Ausgabe der Modellhöhe

    // Stelle sicher, dass das Eingabefeld mit der Tiefe des Modells vorab befüllt wird
 //   document.getElementById('door_thickness').value = modelDepth;
//}, function (xhr) {
//    //console.log((xhr.loaded / xhr.total * 100) + '% loaded');  // Zeige Fortschritt an
//}, function (error) {
//   console.log("Error loading STL model", error);  // Zeige Fehler an
//});

// Event Listener für 'door-thickness' nach dem Laden des Modells
//document.getElementById('door_thickness').addEventListener('input', function () {
  //  var userInput = parseFloat(this.value);
  //  if (!isNaN(userInput) && this.value !== "") {
  //      doorThickness = userInput;  // Wenn der Benutzer einen Wert eingibt, überschreibe doorThickness
  //  } else {
 //       this.value = modelDepth;  // Wenn leer, behalte die Tiefe des Modells bei
  //  }
});




// Boden hinzufügen mit 22% Transparenz
var planeGeometry = new THREE.PlaneGeometry(50, 50); // Größe des Bodens
var planeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x808080, 
    roughness: 0.8,
    transparent: true, 
    opacity: 0.1  // 22% Transparenz
});
var plane = new THREE.Mesh(planeGeometry, planeMaterial);
plane.position.z = -0.1; // Leicht unterhalb des Modells in der z-Achse
scene.add(plane);

// Gitter für die Ansicht hinzufügen
var gridHelper = new THREE.GridHelper(50, 50); // Größe und Anzahl der Linien
gridHelper.rotation.x = Math.PI / 2; // Drehe das Gitter in die x/y-Ebene
scene.add(gridHelper);

// Achsen-Helper hinzufügen und leicht nach oben verschieben, um Überlappung zu vermeiden
var axesHelper = new THREE.AxesHelper(0.1); // Größe der Achsen (z.B. 5 Einheiten)
axesHelper.position.z = 0.001; // Verschiebe die Achsen leicht nach oben
scene.add(axesHelper);

// Lichter für die Szene hinzufügen
var ambientLight = new THREE.AmbientLight(0x404040, 0.5);  // Dunkleres Umgebungslicht
scene.add(ambientLight);

var pointLight1 = new THREE.PointLight(0xffffff, 0.8, 100); // Helligkeit verringert
pointLight1.position.set(10, 10, 10);
scene.add(pointLight1);

var pointLight2 = new THREE.PointLight(0xffffff, 0.8, 100); // Helligkeit verringert
pointLight2.position.set(-10, -10, 10);
scene.add(pointLight2);

var pointLight3 = new THREE.PointLight(0xffffff, 0.8, 100); // Helligkeit verringert
pointLight3.position.set(10, -10, -10);
scene.add(pointLight3);

var pointLight4 = new THREE.PointLight(0xffffff, 0.8, 100); // Helligkeit verringert
pointLight4.position.set(-10, 10, -10);
scene.add(pointLight4);

// Kamera-Position und Steuerung
camera.position.set(0, -1, 0);  // Setze die Kamera näher zum Modell
camera.up.set(0, 0, 1);
camera.lookAt(0, 0, 0);  // Auf das Zentrum der Szene schauen

// OrbitControls
var controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.25;
controls.enableZoom = true;
controls.enablePan = true;
controls.screenSpacePanning = true;

// Deaktiviert die Rotation der Kamera (d.h. Kamera kann nicht gedreht werden)
controls.enableRotate = false;

// Steuerungseigenschaften
controls.rotateSpeed = 0; // Rotation Geschwindigkeit auf 0 setzen, um keine Rotation zu erlauben
controls.zoomSpeed = 1.2;
controls.panSpeed = 1.2;

// Maussteuerung aktivieren
controls.enableRotate = true;

// Render-Schleife
function animate() {
    requestAnimationFrame(animate);
    controls.update();  // Aktualisiere die Steuerung
    renderer.render(scene, camera);  // Render die Szene
}
animate();

// Auswahlmodus aktivieren/deaktivieren
var isSelectionMode = false;
var selectionBox = new THREE.Box3();
var endSelectionCoords = { x: 0, z: 0 };
var startSelectionCoords = { x: 0, z: 0 };

// Linienmaterial für die Auswahlbox
var selectionLineMaterial = new THREE.LineBasicMaterial({
    color: 0xFF6E61,  // Rote Farbe
    linewidth: 10
});

// Geometrie für die Auswahlbox
var selectionGeometry = new THREE.BufferGeometry();
var selectionVertices = new Float32Array(8 * 3);  // 8 Punkte für die Box (jeweils 3 Koordinaten x, y, z)
selectionGeometry.setAttribute('position', new THREE.BufferAttribute(selectionVertices, 3));

var selectionLine = new THREE.LineSegments(selectionGeometry, selectionLineMaterial);
scene.add(selectionLine);

document.getElementById('mode-toggle-button').addEventListener('click', function() {
    isSelectionMode = !isSelectionMode;
    if (isSelectionMode) {
        document.getElementById('mode-toggle-button').textContent = 'Switch to Move';
    } else {
        document.getElementById('mode-toggle-button').textContent = 'Switch to Selection';
    }
});

var pointerdown = false; // Globaler Flag, der den Zustand der Mausverfolgung verwaltet

// Mouse-Event für die Auswahl (beginnend, wenn die linke Maustaste gedrückt wird)
document.getElementById('viewer-container').addEventListener('pointerdown', function (e) {
    if (!isSelectionMode || e.button !== 0) return; // Nur reagieren, wenn die linke Maustaste gedrückt wird

    pointerdown = true; // Auswahl starten

    // Hole die Position und Größe des Containers
    const canvas = renderer.domElement;
    const rect = canvas.getBoundingClientRect();
    
    // Berechne die normalisierten Koordinaten
    const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const mouseZ = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    
    // Umrechnung in Weltkoordinaten unter Berücksichtigung von Kamera- und Zoom-Effekten
    const worldX = (mouseX * (50 * width / height)) / camera.zoom + camera.position.x;
    const worldZ = (mouseZ * 50) / camera.zoom + camera.position.z;

    // Definiere den festen Punkt für den Ray (z.B. auf der Y=50 Ebene)
    var fixedRayOrigin = new THREE.Vector3(worldX, -50, worldZ); 

    // Setze die Richtung des Rays (orthogonal zur XY-Ebene)
    var rayDirection = new THREE.Vector3(worldX, 1, worldZ); 

    // Setze den Ray
    raycaster.ray.origin.copy(fixedRayOrigin);
    raycaster.ray.direction.copy(rayDirection);

    // Setze den Startpunkt der Auswahlbox
    selectionBox.min.set(worldX, -0.01, worldZ);
    selectionBox.max.set(worldX, -0.01, worldZ);

    startSelectionCoords.x = selectionBox.min.x;
    startSelectionCoords.z = selectionBox.min.z;
    // Update der Linien mit den Ecken der Auswahl
    updateSelectionLine();
    document.getElementById('start-coordinates').textContent = `X: ${selectionBox.min.x.toFixed(2)}, Z: ${selectionBox.min.z.toFixed(2)}`;
    document.getElementById('start_coordinates_x').value = startSelectionCoords.x;
    document.getElementById('start_coordinates_z').value = startSelectionCoords.z;
});

// Mouse-Event für das Ziehen und Anpassen der Auswahlbox (nur während der Maustaste gedrückt ist)
document.getElementById('viewer-container').addEventListener('pointermove', function (e) {
    if (!isSelectionMode || !pointerdown) return; // Auswahl erfolgt nur, wenn die Maustaste gedrückt wird

    // Hole das Canvas-Element und seine Position im Browserfenster
    const canvas = renderer.domElement;
    const rect = canvas.getBoundingClientRect();
    
    // Berechne die normalisierten Koordinaten
    const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const mouseZ = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    
    // Umrechnung in Weltkoordinaten
    const worldX = (mouseX * (50 * width / height)) / camera.zoom + camera.position.x;
    const worldZ = (mouseZ * 50) / camera.zoom + camera.position.z;

    // Setze den Endpunkt der Auswahlbox
    selectionBox.max.set(worldX, -0.01, worldZ);
    updateSelectionLine();
    endSelectionCoords.x = selectionBox.max.x;
    endSelectionCoords.z = selectionBox.max.z;

    // Aktualisiere die angezeigten Koordinaten
    document.getElementById('end-coordinates').textContent = `X: ${selectionBox.max.x.toFixed(2)}, Z: ${selectionBox.max.z.toFixed(2)}`;
    document.getElementById('start_coordinates_x').value = startSelectionCoords.x;
    document.getElementById('start_coordinates_z').value = startSelectionCoords.z;
    document.getElementById('end_coordinates_x').value = endSelectionCoords.x;
    document.getElementById('end_coordinates_z').value = endSelectionCoords.z;
});

function calculateScale() {
    // Holen Sie sich die Eingabewerte für die Dimension
    const scaleDimensionInput = document.getElementById('scale_dimension');
    const scaleDimension = parseFloat(scaleDimensionInput.value);

    if (isNaN(scaleDimension) || scaleDimension <= 0) {
        console.error("Invalid scale dimension. Please enter a positive number.");
        return;
    }

    // Berechnung der aktuellen Breite basierend auf den Koordinaten
    const selectionWidth = Math.abs(endSelectionCoords.x - startSelectionCoords.x);

    if (selectionWidth === 0) {
        console.error("Selection width is zero. Ensure you have selected a valid area.");
        return;
    }

    // Skalierungsfaktor berechnen
    const scaleFactor = scaleDimension / selectionWidth / 100;
    console.log(`Calculated Scale Factor: ${scaleFactor}`);
    document.getElementById('scale_factor').value = scaleFactor;
    
    // Sie können hier den Skalierungsfaktor verwenden, um das Modell zu skalieren
    // Beispiel: mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
}
function calculateMinMaxY() {
    if (!mesh) {
        console.error('Mesh is not loaded yet!');
        return;
    }

    // Überprüfe, ob die Geometrie des Modells vorhanden ist
    if (!mesh.geometry || !mesh.geometry.attributes.position) {
        console.error('Mesh geometry or position attribute is undefined!');
        return;
    }

    // Hole die Position der Vertices
    const positions = mesh.geometry.attributes.position.array;

    let minY = Infinity;
    let maxY = -Infinity;

    // Durchlaufe alle Vertices und bestimme min/max Y-Werte
    for (let i = 0; i < positions.length; i += 3) { // 3 für x, y, z
        const x = positions[i];
        const y = positions[i + 1];
        const z = positions[i + 2];

        // Überprüfe, ob der Punkt innerhalb der Auswahlbox liegt (nur x und z Koordinaten)
        if (x >= selectionBox.min.x && x <= selectionBox.max.x &&
            z >= selectionBox.min.z && z <= selectionBox.max.z) {
            // Aktualisiere min/max Y-Werte
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        }
    }

    // Überprüfe, ob minY und maxY aktualisiert wurden
    if (minY === Infinity || maxY === -Infinity) {
        console.log('No vertices found within the selection box');
    } else {
        console.log("minY:", minY, "maxY:", maxY);
        document.getElementById('minY').value = minY;
        document.getElementById('maxY').value = maxY;
    }
}

// Mouse-Event für das Beenden der Auswahl (pointerup)
document.getElementById('viewer-container').addEventListener('pointerup', function (e) {
    if (!isSelectionMode || e.button !== 0) return; // Nur reagieren, wenn die linke Maustaste losgelassen wird

    pointerdown = false; // Setze den Flag zurück, wenn die Maus losgelassen wird

    // Finalisiere die Auswahlbox, um die Endkoordinaten zu setzen
    selectionBox.max.set(selectionBox.max.x, -0.01, selectionBox.max.z);

    // Aktualisiere die Linien der Auswahl
    updateSelectionLine();
    calculateScale();
    document.getElementById('start_coordinates_x').value = startSelectionCoords.x;
    document.getElementById('start_coordinates_z').value = startSelectionCoords.z;
    document.getElementById('end_coordinates_x').value = endSelectionCoords.x;
    document.getElementById('end_coordinates_z').value = endSelectionCoords.z;
    calculateMinMaxY();
    
    console.log("Auswahl abgeschlossen!");
    
});




// Funktion zum Aktualisieren der Linien
function updateSelectionLine() {
    var positions = selectionLine.geometry.attributes.position.array;
    var min = selectionBox.min;
    var max = selectionBox.max;

    // Update der Eckpunkte der Auswahlbox
    positions[0] = min.x; positions[1] = min.y; positions[2] = min.z;
    positions[3] = max.x; positions[4] = min.y; positions[5] = min.z;
    positions[6] = max.x; positions[7] = min.y; positions[8] = min.z;
    positions[9] = max.x; positions[10] = min.y; positions[11] = max.z;
    positions[12] = max.x; positions[13] = min.y; positions[14] = max.z;
    positions[15] = min.x; positions[16] = min.y; positions[17] = max.z;
    positions[18] = min.x; positions[19] = min.y; positions[20] = max.z;
    positions[21] = min.x; positions[22] = min.y; positions[23] = min.z;

    selectionLine.geometry.attributes.position.needsUpdate = true;
}

document.getElementById('scale_dimension').addEventListener('input', function () {
    const scaleDimension = parseFloat(this.value);

    // Nur berechnen, wenn eine Auswahl getroffen wurde und das Eingabefeld einen gültigen Wert enthält
    if (!isNaN(scaleDimension) && scaleDimension > 0 && endSelectionCoords.x !== startSelectionCoords.x) {
        calculateScale();
    }
});
document.getElementById('door_thickness').addEventListener('input', function () {
    doorThickness = document.getElementById('door_thickness').value;
    document.getElementById('hidden_door_thickness').value = doorThickness;
    console.log('Door Thickness:', doorThickness)
});


    </script>
</body>
</html>