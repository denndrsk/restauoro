{% load static %}
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clean up</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="{% static 'css/styles_viewer.css' %}">
    
</head>
<body>

    <!-- Statusnachricht anzeigen -->
    <div id="status-message" class="{% if is_watertight %}success{% else %}error{% endif %}" style="font-weight: bold; font-size: 20px;">
        {% if is_watertight %}
            The model is watertight and ready to go!
        {% else %}
            The model is not watertight. Check the algorithm & raw model :(
        {% endif %}
    </div>
    

    <!-- Container für den STL-Viewer -->
    <div id="viewer-container"></div>

    <!-- Buttons unter dem Viewer -->
    <div id="buttons-container">
        <!-- Bereinigung fehlerhaft Button (zurück zu Step 2) -->
        <form method="POST" action="{% url 'step2_viewer' project_id=project_id %}">
            {% csrf_token %}
            
            <button type="submit" class="red-button">Clean up unsuccessful</button>
        </form>

        <!-- Nächster Schritt Button (Modell bereinigt) -->
        <form method="POST" action="{% url 'step4_filling_piece' project_id=project_id %}">
            {% csrf_token %}
            <input type="hidden" name="scale_factor" value="{{ scale_factor }}">
            <input type="hidden" name="hidden_door_thickness" value="{{ hidden_door_thickness }}">
            <button type="submit" class="yellow-button">Generate a filling piece</button>
        </form>
    </div>

    <!-- Three.js und STLLoader einbinden -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Szene, Kamera und Renderer initialisieren
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.8);  // Dynamische Größenanpassung
        document.getElementById('viewer-container').appendChild(renderer.domElement);

        // STLLoader und Modell-URL laden
        var loader = new THREE.STLLoader();
        var modelUrl = "{{ model_url }}";  // URL des bearbeiteten Modells
        

        loader.load(modelUrl, function (geometry) {
            var material = new THREE.MeshStandardMaterial({ 
                color: 0x8A8A8A,  // Dunkleres Grau
                roughness: 0.5, 
                metalness: 0.1 
            });
            var mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            mesh.position.set(0, 0, 0); // Position des Modells in der Mitte der Szene
            mesh.scale.set(1, 1, 1); // Skalierung des Modells
        });

        // Boden hinzufügen mit 22% Transparenz
        var planeGeometry = new THREE.PlaneGeometry(50, 50); // Größe des Bodens
        var planeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x808080, 
            roughness: 0.8,
            transparent: true, 
            opacity: 0.1  // 22% Transparenz
        });
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.position.z = -0.1; // Leicht unterhalb des Modells in der z-Achse
        scene.add(plane);

        // Gitter für die Ansicht hinzufügen
        var gridHelper = new THREE.GridHelper(50, 50); // Größe und Anzahl der Linien
        gridHelper.rotation.x = Math.PI / 2; // Drehe das Gitter in die x/y-Ebene
        scene.add(gridHelper);

        // Achsen-Helper hinzufügen und leicht nach oben verschieben, um Überlappung zu vermeiden
        var axesHelper = new THREE.AxesHelper(0.1); // Größe der Achsen (z.B. 5 Einheiten)
        axesHelper.position.z = 0.001; // Verschiebe die Achsen leicht nach oben
        scene.add(axesHelper);

        // Lichter für die Szene hinzufügen
        var ambientLight = new THREE.AmbientLight(0x404040, 0.5);  // Dunkleres Umgebungslicht
        scene.add(ambientLight);

        var pointLight1 = new THREE.PointLight(0xffffff, 0.8, 100); // Helligkeit verringert
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);

        var pointLight2 = new THREE.PointLight(0xffffff, 0.8, 100); // Helligkeit verringert
        pointLight2.position.set(-10, -10, 10);
        scene.add(pointLight2);

        var pointLight3 = new THREE.PointLight(0xffffff, 0.8, 100); // Helligkeit verringert
        pointLight3.position.set(10, -10, -10);
        scene.add(pointLight3);

        var pointLight4 = new THREE.PointLight(0xffffff, 0.8, 100); // Helligkeit verringert
        pointLight4.position.set(-10, 10, -10);
        scene.add(pointLight4);

        // Kamera-Position und Steuerung
        camera.position.set(-3, -3, 5);
        camera.up.set(0, 0, 1);
        camera.lookAt(0, 0, 2);
              


        //orbitcontrolls ----------------------------------------------------------------
        var controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Dämpfung aktivieren
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        // Zoom und Panning aktivieren
        controls.enableZoom = true;
        controls.enablePan = true; // Ermöglicht das Verschieben in der Höhe

        // Panning für die vertikale Bewegung erlauben
        controls.screenSpacePanning = true; // Deaktiviert Panning nur auf der X/Y-Ebene

        // Maximale Neigung der Kamera (verhindert das Kippen des Modells nach unten)
        //controls.maxPolarAngle = Math.PI / 2; // Verhindert das Kippen unter den Horizont

        // Steuere die Rotationsgeschwindigkeit
        controls.rotateSpeed = 1.5; // Höhere Werte erhöhen die Drehgeschwindigkeit

        // Steuere die Zoomgeschwindigkeit
        controls.zoomSpeed = 1.2; // Steuere die Zoomgeschwindigkeit

        //orbitcontrolls ----------------------------------------------------------------


        // Animations-Loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            controls.update();
        }

        animate();

        // Anpassung der Anzeige bei Fenstergrößeänderung
        window.addEventListener('resize', function () {
            renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.8);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
